import type { Subscription } from 'rxjs'
import { Subject } from 'rxjs'
import { catchError, groupBy, map, mergeMap, tap, throttleTime } from 'rxjs/operators'
import { defaultResolver, serialize } from './resolver'

// Payload for the main trigger subject
interface MainTriggerPayload<Args extends any[], Ctx, K, R> {
  args: Args
  callContext: Ctx
  groupKey: K
  resolve: (value: R) => void
  reject: (reason?: any) => void
  assignedExecutionId: number // The ID assigned to this specific call within its group
}

/**
 * Creates a throttled version of an asynchronous function, with queries grouped by a key
 * generated by the resolver function. Throttling is applied independently for each group using RxJS groupBy.
 *
 * Within each group:
 * 1. All promises resolve/reject with the result of the LATEST INITIATED and
 * SUCCESSFULLY COMPLETED actual `asyncFn` execution for that group.
 * 2. If an `asyncFn` execution (A) for a group completes, but a newer execution (B) for the
 * same group has already been *initiated* (its assignedExecutionId is higher), A's result is stale.
 *
 * @template Args - asyncFn 参数的类型数组。
 * @template R - asyncFn 返回的 Promise 解析值的类型。
 * @template Ctx - asyncFn 执行时的 `this` 上下文类型。
 * @param {function(this: Ctx, ...args: Args): Promise<R>} asyncFn 要进行节流的异步函数。
 * @param {number} duration 节流的持续时间（毫秒）。
 * @param {function(this: Ctx, ...args: Args): K} resolver 函数，用于从查询参数生成分组键。
 * @returns {function(this: Ctx, ...args: Args): Promise<R>} 返回一个新的节流异步函数。
 */
export function throttleQuery<Args extends any[], R, Ctx = any>(
  asyncFn: (this: Ctx, ...args: Args) => Promise<R>,
  duration: number,
  resolver?: (this: Ctx, ...args: Args) => any,
): (this: Ctx, ...args: Args) => Promise<R> {
  const mainTrigger$ = new Subject<MainTriggerPayload<Args, Ctx, string, R>>()
  const groupCallIdCounters = new Map<string, number>() // Stores the next execution ID for each group

  const mainSubscription: Subscription = mainTrigger$.pipe(
    groupBy(payload => payload.groupKey),
    mergeMap((group$) => {
      let groupLatestAssignedExecutionId = 0 // Tracks the latest ID *assigned* to a call in this group
      const groupPendingResolves = new Set<(value: R) => void>()
      const groupPendingRejects = new Set<(reason?: any) => void>()

      return group$.pipe(
        tap((payload) => {
          groupPendingResolves.add(payload.resolve)
          groupPendingRejects.add(payload.reject)
          groupLatestAssignedExecutionId = payload.assignedExecutionId
        }),
        throttleTime(duration, undefined, { leading: false, trailing: true }),
        map(async (throttledPayload) => {
          const { args, callContext, assignedExecutionId } = throttledPayload

          try {
            const result = await asyncFn.apply(callContext, args)

            if (assignedExecutionId === groupLatestAssignedExecutionId) {
              const currentResolves = Array.from(groupPendingResolves)
              groupPendingResolves.clear()
              groupPendingRejects.clear()
              currentResolves.forEach(resolveFunc => resolveFunc(result))
            }
          }
          catch (error) {
            if (assignedExecutionId === groupLatestAssignedExecutionId) {
              const currentRejects = Array.from(groupPendingRejects)
              groupPendingResolves.clear()
              groupPendingRejects.clear()
              currentRejects.forEach(rejectFunc => rejectFunc(error))
            }
          }
        }),
        catchError((error, _caught) => {
          const currentRejects = Array.from(groupPendingRejects)
          groupPendingResolves.clear()
          groupPendingRejects.clear()
          currentRejects.forEach(rejectFunc => rejectFunc(error))
          return [] // End this group's stream gracefully after error.
        }),
      )
    }),
  ).subscribe()

  return async function (this: Ctx, ...args: Args): Promise<R> {
    let groupKey: string

    try {
      groupKey = serialize((resolver || defaultResolver).apply(this, args))
    }
    catch (e: any) {
      return Promise.reject(new Error(`Resolver function failed: ${e.message || e}`))
    }

    if (mainSubscription.closed) {
      return Promise.reject(new Error('throttleQuery stream is closed. Cannot process new queries.'))
    }

    if (!groupCallIdCounters.has(groupKey)) {
      groupCallIdCounters.set(groupKey, 0)
    }
    const assignedExecutionId = groupCallIdCounters.set(groupKey, groupCallIdCounters.get(groupKey)! + 1).get(groupKey)!

    return new Promise<R>((resolve, reject) => {
      mainTrigger$.next({ args, callContext: this, groupKey, resolve, reject, assignedExecutionId })
    })
  }
}

/**
 * Creates a cached version of an asynchronous function, with queries grouped by a key
 * generated by the resolver function. Results are cached for the specified TTL duration.
 *
 * Within each group:
 * 1. The first call triggers the actual query execution
 * 2. Subsequent calls within TTL will receive the cached result
 * 3. After TTL expires, the next call will trigger a new query execution
 *
 * @template Args - asyncFn 参数的类型数组。
 * @template R - asyncFn 返回的 Promise 解析值的类型。
 * @template Ctx - asyncFn 执行时的 `this` 上下文类型。
 * @param {function(this: Ctx, ...args: Args): Promise<R>} asyncFn 要缓存的异步函数。
 * @param {number} ttl 缓存的有效期（毫秒）。
 * @param {function(this: Ctx, ...args: Args): K} resolver 函数，用于从查询参数生成分组键。
 * @param {number} maxSize 缓存的最大大小。
 * @returns {function(this: Ctx, ...args: Args): Promise<R>} 返回一个新的带缓存的异步函数。
 */
export function cacheQuery<Args extends any[], R, Ctx = any>(
  asyncFn: (this: Ctx, ...args: Args) => Promise<R>,
  ttl: number,
  resolver?: (this: Ctx, ...args: Args) => any,
  maxSize?: number,
): (this: Ctx, ...args: Args) => Promise<R> {
  const cache = new Map<string, {
    result: Promise<R>
    timestamp: number
  }>()

  return async function (this: Ctx, ...args: Args): Promise<R> {
    let groupKey: string

    try {
      groupKey = serialize((resolver || defaultResolver).apply(this, args))
    }
    catch (e: any) {
      return Promise.reject(new Error(`Resolver function failed: ${e.message || e}`))
    }

    const now = Date.now()
    const cached = cache.get(groupKey)

    if (cached && now - cached.timestamp < ttl) {
      return cached.result
    }

    let result = asyncFn.apply(this, args)
    result = result.catch((error) => {
      cache.delete(groupKey)
      throw error
    })
    if (cache.size >= (maxSize || 100)) {
      // LRU
      cache.delete([...cache.keys()].shift()!)
    }
    cache.set(groupKey, {
      result,
      timestamp: now,
    })

    return result
  }
}
